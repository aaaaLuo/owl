# AI对话系统执行流程

## 1. 系统流程

### 初始化阶段
- **设定角色身份**
  - User角色: 提供指令和任务需求
  - Assistant角色: 执行任务并提供解决方案
  - (可选) 特定领域角色: 如任务规划Agent、浏览器工具Agent等
- **加载系统提示词**
  - 示例: 定义规则（如"永远不要忘记你是user，而我是assistant。切勿角色互换"、"回复格式为Solution+Next request"）
- **明确任务目标**
  - 示例: User指定"编写一个Python程序"或"分析市场趋势"

### 执行阶段
- **循环开始**
  - User提供具体指令
    - 示例: "通过浏览器在微信搜索 Agent 获取第一篇文章"
  - Assistant执行任务
    - 检查是否可执行
      - 若可行 → 生成解决方案
      - 若不可行 → 诚实拒绝
  - Assistant回复
    - 格式: Solution: <解决方案> \n Next request.
  - 检查任务是否完成
    - 未完成 → 返回上一步（User继续提供指令）
    - 已完成 → 进入结束阶段
- **循环结束**

### 结束阶段

### 流程图示例
[开始]
   ↓
[初始化阶段]
   ├── 1. 设定角色身份
   │    ├── User角色：提供指令和任务需求
   │    ├── Assistant角色：执行任务并提供解决方案
   │    └── (可选) 特定领域角色：如任务规划Agent、浏览器工具Agent等
   ├── 2. 加载系统提示词
   │    └── 示例：定义规则（如“永不翻转角色”、“回复格式为Solution+Next request”）
   └── 3. 明确任务目标
         └── 示例：User指定“编写一个Python程序”或“分析市场趋势”
   ↓
[执行阶段]
   ├── [循环开始]
   │    ├── 4. User提供具体指令
   │    │    └── 示例：“通过浏览器在微信搜索 Agent 获取第一篇文章”
   │    ├── 5. Assistant执行任务
   │    │    └── 检查是否可执行
   │    │         ├── 若可行 → 生成解决方案
   │    │         └── 若不可行 → 诚实拒绝
   │    ├── 6. Assistant回复
   │    │    └── 格式：Solution: <解决方案> \n Next request.
   │    └── 7. 检查任务是否完成
   │         ├── 未完成 → 返回步骤4（User继续提供指令）
   │         └── 已完成 → 进入[结束]
   └── [循环结束]
   ↓
[结束]

---

## 2. 消息结构分析

### User消息结构
```
BaseMessage(
  role_name='user', 
  role_type=<RoleType.USER: 'user'>,
  meta_dict={
    'task': '浏览亚马逊通过关键字 编程助手 找到第一个商品。请提供产品名称和价格', 
    'assistant_role': 'assistant', 
    'user_role': 'user'
  },
  content='===== 用户规则 =====
  永远不要忘记你是user，而我是assistant。切勿角色互换！你将始终指导我。
  我们有共同的兴趣合作成功完成任务。
  我必须帮助你完成任务。
  这是任务：浏览亚马逊通过关键字 编程助手 找到第一个商品。请提供产品名称和价格。永远不要忘记我们的任务！
  ...'
)
```

### 系统提示结构
```
[
  {
    'role': 'system',
    'content': '===== 用户规则 =====\n永远不要忘记你是user，而我是assistant。...'
  },
  {
    'role': 'user',
    'content': '\n    现在请给我一步步解决总体任务的指示。...'
  }
]
```

### 角色定义
- **User**: 指导者/任务分解者
- **Assistant**: 执行者/任务实施者

---

## 3. 系统设计分析

### 设计意图
```python
# 设计意图分析
"""
核心目标: 建立一个结构化的指令执行框架
角色定位: 用户(提示者)和助手(执行者)的明确分工
任务模式: 基于指令驱动的任务分解和执行
"""
```

### 主要设计特点

#### 角色定义与约束
```
角色划分:
- User: 指导者/任务分解者
- Assistant: 执行者/任务实施者

强制约束:
- 角色固定不可互换
- 明确的交互规则
```

#### 通信协议设计
```
两种标准化指令格式:
1. 带输入指令:
   指令：<具体指令>
   输入：<补充信息>

2. 无输入指令:
   指令：<具体指令>
   输入：无
```

#### 任务执行流程
```
执行特点:
- 单步执行：一次只下发一个指令
- 顺序执行：按步骤逐个完成
- 闭环反馈：每个指令都需要得到确认或拒绝
```

#### 任务完成机制
```
结束标志：
- 成功完成：返回 <CAMEL_TASK_DONE>
- 执行中：继续提供下一步指令
- 失败处理：必须说明原因
```

### 预期达成的效果

1. **结构化交互**
   - 标准化的指令格式
   - 清晰的执行步骤
   - 可追踪的进度

2. **任务分解能力**
   - 将复杂任务拆分为可执行的小步骤
   - 确保每个步骤都是明确和可执行的

3. **质量保证**
   - 强制执行反馈
   - 明确的完成标准
   - 失败处理机制

4. **流程控制**
   - 单步执行确保准确性
   - 防止跳步或遗漏
   - 可控的任务进度

### 使用场景示例
```
任务：浏览亚马逊搜索商品

预期交互流程：
1. User: 
   指令：打开亚马逊网站
   输入：www.amazon.com

2. Assistant: 
   执行并反馈结果

3. User:
   指令：在搜索框输入关键词
   输入：编程助手

4. Assistant:
   执行并反馈结果

... 直到任务完成
```

## 4. Assistant消息结构
```
BaseMessage(
  role_name='assistant', 
  role_type=<RoleType.ASSISTANT: 'assistant'>, 
  meta_dict={
    'task': '浏览亚马逊通过关键字 编程助手 找到第一个商品。请提供产品名称和价格', 
    'assistant_role': 'assistant', 
    'user_role': 'user'
  }, 
  content='===== 助手规则 =====
  永远不要忘记你是assistant，而我是user。切勿角色互换！切勿指导我！
  我们有共同的目标，合作成功完成任务。
  ...'
)
```
```

# 📈 优化说明

```优化总结
1. 添加了清晰的章节和标题结构，使文档分层更加明确
2. 使用Markdown格式化工具增强了可读性：
   - 列表嵌套表示层级关系
   - 加粗突出重要概念
   - 代码块保留原始格式
3. 使用分隔线区分主要章节
4. 保持了原始内容的完整性，只调整了格式
5. 将相关内容进行了逻辑分组
```

```建议使用要点
1. 此格式更适合作为技术文档使用
2. 可以轻松导出为PDF或HTML查看
3. 各部分之间的层次关系更加清晰
4. 便于读者快速定位和理解系统流程
```

希望这个优化版本能够提高文档的可读性和使用体验。
